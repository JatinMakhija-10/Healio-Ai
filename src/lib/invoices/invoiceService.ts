import { supabase } from '@/lib/supabase';

export interface Invoice {
    id: string;
    invoice_number: string;
    appointment_id: string;
    doctor_id: string;
    patient_id: string;
    clinical_notes_id?: string;
    consultation_fee: number;
    platform_fee_percentage: number;
    platform_fee: number;
    doctor_payout: number;
    total_amount: number;
    status: 'pending' | 'approved' | 'rejected' | 'paid' | 'cancelled';
    submitted_at: string;
    reviewed_at?: string;
    reviewed_by?: string;
    paid_at?: string;
    admin_notes?: string;
    rejection_reason?: string;
    created_at: string;
    updated_at: string;
}

export interface CreateInvoiceData {
    appointment_id: string;
    doctor_id: string;
    patient_id: string;
    clinical_notes_id?: string;
    consultation_fee: number;
    platform_fee_percentage?: number;
}

export interface ReviewInvoiceData {
    status: 'approved' | 'rejected';
    admin_notes?: string;
    rejection_reason?: string;
}

class InvoiceService {
    /**
     * Create a new invoice
     */
    async createInvoice(data: CreateInvoiceData): Promise<Invoice> {


        const { data: invoice, error } = await supabase
            .from('invoices')
            .insert({
                appointment_id: data.appointment_id,
                doctor_id: data.doctor_id,
                patient_id: data.patient_id,
                clinical_notes_id: data.clinical_notes_id,
                consultation_fee: data.consultation_fee,
                platform_fee_percentage: data.platform_fee_percentage || 20.00,
                status: 'pending',
                invoice_number: '' // Will be auto-generated by trigger
            })
            .select()
            .single();

        if (error) throw error;
        return invoice;
    }

    /**
     * Get invoice by ID
     */
    async getInvoiceById(id: string): Promise<Invoice | null> {


        const { data, error } = await supabase
            .from('invoices')
            .select('*')
            .eq('id', id)
            .single();

        if (error) {
            if (error.code === 'PGRST116') return null;
            throw error;
        }
        return data;
    }

    /**
     * Get invoice by appointment ID
     */
    async getInvoiceByAppointment(appointmentId: string): Promise<Invoice | null> {


        const { data, error } = await supabase
            .from('invoices')
            .select('*')
            .eq('appointment_id', appointmentId)
            .single();

        if (error) {
            if (error.code === 'PGRST116') return null;
            throw error;
        }
        return data;
    }

    /**
     * Get all invoices for a doctor
     */
    async getDoctorInvoices(doctorId: string, filters?: {
        status?: string;
        startDate?: string;
        endDate?: string;
    }): Promise<Invoice[]> {


        let query = supabase
            .from('invoices')
            .select('*')
            .eq('doctor_id', doctorId)
            .order('submitted_at', { ascending: false });

        if (filters?.status) {
            query = query.eq('status', filters.status);
        }

        if (filters?.startDate) {
            query = query.gte('submitted_at', filters.startDate);
        }

        if (filters?.endDate) {
            query = query.lte('submitted_at', filters.endDate);
        }

        const { data, error } = await query;

        if (error) throw error;
        return data || [];
    }

    /**
     * Get all pending invoices (for admin)
     */
    async getPendingInvoices(): Promise<Invoice[]> {


        const { data, error } = await supabase
            .from('invoices')
            .select('*')
            .eq('status', 'pending')
            .order('submitted_at', { ascending: true });

        if (error) throw error;
        return data || [];
    }

    /**
     * Get all invoices (for admin)
     */
    async getAllInvoices(filters?: {
        status?: string;
        startDate?: string;
        endDate?: string;
    }): Promise<Invoice[]> {


        let query = supabase
            .from('invoices')
            .select('*')
            .order('submitted_at', { ascending: false });

        if (filters?.status) {
            query = query.eq('status', filters.status);
        }

        if (filters?.startDate) {
            query = query.gte('submitted_at', filters.startDate);
        }

        if (filters?.endDate) {
            query = query.lte('submitted_at', filters.endDate);
        }

        const { data, error } = await query;

        if (error) throw error;
        return data || [];
    }

    /**
     * Review invoice (admin only)
     */
    async reviewInvoice(id: string, review: ReviewInvoiceData, reviewerId: string): Promise<Invoice> {


        const { data, error } = await supabase
            .from('invoices')
            .update({
                status: review.status,
                admin_notes: review.admin_notes,
                rejection_reason: review.status === 'rejected' ? review.rejection_reason : null,
                reviewed_at: new Date().toISOString(),
                reviewed_by: reviewerId
            })
            .eq('id', id)
            .select()
            .single();

        if (error) throw error;
        return data;
    }

    /**
     * Approve invoice (admin only)
     */
    async approveInvoice(id: string, adminNotes: string | undefined, adminId: string): Promise<Invoice> {
        return this.reviewInvoice(id, { status: 'approved', admin_notes: adminNotes }, adminId);
    }

    /**
     * Reject invoice (admin only)
     */
    async rejectInvoice(id: string, reason: string, adminId: string): Promise<Invoice> {
        return this.reviewInvoice(id, { status: 'rejected', rejection_reason: reason }, adminId);
    }

    /**
     * Mark invoice as paid
     */
    async markInvoiceAsPaid(id: string): Promise<Invoice> {


        const { data, error } = await supabase
            .from('invoices')
            .update({
                status: 'paid',
                paid_at: new Date().toISOString()
            })
            .eq('id', id)
            .select()
            .single();

        if (error) throw error;
        return data;
    }

    /**
     * Get doctor's revenue summary
     */
    async getDoctorRevenueSummary(doctorId: string, startDate?: string, endDate?: string): Promise<{
        totalRevenue: number;
        pendingRevenue: number;
        approvedRevenue: number;
        paidRevenue: number;
        totalInvoices: number;
        pendingInvoices: number;
        approvedInvoices: number;
        paidInvoices: number;
    }> {
        const invoices = await this.getDoctorInvoices(doctorId, { startDate, endDate });

        const summary = {
            totalRevenue: 0,
            pendingRevenue: 0,
            approvedRevenue: 0,
            paidRevenue: 0,
            totalInvoices: invoices.length,
            pendingInvoices: 0,
            approvedInvoices: 0,
            paidInvoices: 0
        };

        invoices.forEach(invoice => {
            if (invoice.status === 'pending') {
                summary.pendingRevenue += invoice.doctor_payout;
                summary.pendingInvoices++;
            } else if (invoice.status === 'approved') {
                summary.approvedRevenue += invoice.doctor_payout;
                summary.approvedInvoices++;
            } else if (invoice.status === 'paid') {
                summary.paidRevenue += invoice.doctor_payout;
                summary.paidInvoices++;
                summary.totalRevenue += invoice.doctor_payout;
            }
        });

        return summary;
    }

    /**
     * Get platform revenue summary (admin only)
     */
    async getPlatformRevenueSummary(): Promise<{
        totalPlatformRevenue: number;
        totalTransactionVolume: number;
        pendingPlatformRevenue: number;
        totalInvoices: number;
        paidInvoices: number;
    }> {


        const { data, error } = await supabase
            .from('platform_revenue_summary')
            .select('*')
            .single();

        if (error) throw error;

        return {
            totalPlatformRevenue: Number(data.total_platform_revenue),
            totalTransactionVolume: Number(data.total_transaction_volume),
            pendingPlatformRevenue: Number(data.pending_platform_revenue),
            totalInvoices: data.total_invoices,
            paidInvoices: data.paid_invoices
        };
    }
}

export const invoiceService = new InvoiceService();

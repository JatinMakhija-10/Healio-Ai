import { supabase } from '@/lib/supabase';

export interface Transaction {
    id: string;
    transaction_id: string;
    invoice_id: string;
    appointment_id: string;
    doctor_id: string;
    patient_id: string;
    transaction_type: 'payment' | 'payout' | 'refund' | 'fee';
    amount: number;
    currency: string;
    payment_method?: string;
    gateway_transaction_id?: string;
    gateway_response?: any;
    status: 'pending' | 'processing' | 'completed' | 'failed' | 'refunded';
    processed_at?: string;
    failed_reason?: string;
    metadata?: any;
    created_at: string;
    updated_at: string;
}

export interface CreateTransactionData {
    invoice_id: string;
    appointment_id: string;
    doctor_id: string;
    patient_id: string;
    transaction_type: 'payment' | 'payout' | 'refund' | 'fee';
    amount: number;
    payment_method?: string;
    metadata?: any;
}

class PaymentService {
    /**
     * Create a transaction record
     */
    async createTransaction(data: CreateTransactionData): Promise<Transaction> {


        const { data: transaction, error } = await supabase
            .from('transactions')
            .insert({
                invoice_id: data.invoice_id,
                appointment_id: data.appointment_id,
                doctor_id: data.doctor_id,
                patient_id: data.patient_id,
                transaction_type: data.transaction_type,
                amount: data.amount,
                currency: 'INR',
                payment_method: data.payment_method || 'mock',
                status: 'pending',
                metadata: data.metadata,
                transaction_id: '' // Will be auto-generated by trigger
            })
            .select()
            .single();

        if (error) throw error;
        return transaction;
    }

    /**
     * Process payment for an approved invoice
     */
    async processInvoicePayment(invoiceId: string): Promise<{
        platformFeeTransaction: Transaction;
        doctorPayoutTransaction: Transaction;
    }> {


        // Get invoice details
        const { data: invoice, error: invoiceError } = await supabase
            .from('invoices')
            .select('*')
            .eq('id', invoiceId)
            .single();

        if (invoiceError) throw invoiceError;
        if (!invoice) throw new Error('Invoice not found');
        if (invoice.status !== 'approved') {
            throw new Error('Invoice must be approved before processing payment');
        }

        // Create platform fee transaction
        const platformFeeTransaction = await this.createTransaction({
            invoice_id: invoiceId,
            appointment_id: invoice.appointment_id,
            doctor_id: invoice.doctor_id,
            patient_id: invoice.patient_id,
            transaction_type: 'fee',
            amount: invoice.platform_fee,
            metadata: {
                type: 'platform_fee',
                percentage: invoice.platform_fee_percentage
            }
        });

        // Create doctor payout transaction
        const doctorPayoutTransaction = await this.createTransaction({
            invoice_id: invoiceId,
            appointment_id: invoice.appointment_id,
            doctor_id: invoice.doctor_id,
            patient_id: invoice.patient_id,
            transaction_type: 'payout',
            amount: invoice.doctor_payout,
            metadata: {
                type: 'doctor_payout'
            }
        });

        // Process payments with mock gateway
        await this.processMockPayment(platformFeeTransaction.id);
        await this.processMockPayment(doctorPayoutTransaction.id);

        // Mark invoice as paid
        await supabase
            .from('invoices')
            .update({
                status: 'paid',
                paid_at: new Date().toISOString()
            })
            .eq('id', invoiceId);

        // Update appointment payment status
        await supabase
            .from('appointments')
            .update({
                payment_status: 'paid'
            })
            .eq('id', invoice.appointment_id);

        return {
            platformFeeTransaction: await this.getTransactionById(platformFeeTransaction.id) as Transaction,
            doctorPayoutTransaction: await this.getTransactionById(doctorPayoutTransaction.id) as Transaction
        };
    }

    /**
     * Mock payment processing (simulates payment gateway)
     */
    private async processMockPayment(transactionId: string): Promise<Transaction> {


        // Simulate processing delay
        await new Promise(resolve => setTimeout(resolve, 500));

        // Update transaction to completed
        const { data, error } = await supabase
            .from('transactions')
            .update({
                status: 'completed',
                processed_at: new Date().toISOString(),
                gateway_transaction_id: `MOCK-${Date.now()}-${Math.random().toString(36).substring(7)}`,
                gateway_response: {
                    success: true,
                    gateway: 'mock',
                    timestamp: new Date().toISOString()
                }
            })
            .eq('id', transactionId)
            .select()
            .single();

        if (error) throw error;
        return data;
    }

    /**
     * Get transaction by ID
     */
    async getTransactionById(id: string): Promise<Transaction | null> {


        const { data, error } = await supabase
            .from('transactions')
            .select('*')
            .eq('id', id)
            .single();

        if (error) {
            if (error.code === 'PGRST116') return null;
            throw error;
        }
        return data;
    }

    /**
     * Get transactions for a doctor
     */
    async getDoctorTransactions(doctorId: string, filters?: {
        type?: string;
        status?: string;
        startDate?: string;
        endDate?: string;
    }): Promise<Transaction[]> {


        let query = supabase
            .from('transactions')
            .select('*')
            .eq('doctor_id', doctorId)
            .order('created_at', { ascending: false });

        if (filters?.type) {
            query = query.eq('transaction_type', filters.type);
        }

        if (filters?.status) {
            query = query.eq('status', filters.status);
        }

        if (filters?.startDate) {
            query = query.gte('created_at', filters.startDate);
        }

        if (filters?.endDate) {
            query = query.lte('created_at', filters.endDate);
        }

        const { data, error } = await query;

        if (error) throw error;
        return data || [];
    }

    /**
     * Get all transactions (admin only)
     */
    async getAllTransactions(filters?: {
        type?: string;
        status?: string;
        startDate?: string;
        endDate?: string;
    }): Promise<Transaction[]> {


        let query = supabase
            .from('transactions')
            .select('*')
            .order('created_at', { ascending: false });

        if (filters?.type) {
            query = query.eq('transaction_type', filters.type);
        }

        if (filters?.status) {
            query = query.eq('status', filters.status);
        }

        if (filters?.startDate) {
            query = query.gte('created_at', filters.startDate);
        }

        if (filters?.endDate) {
            query = query.lte('created_at', filters.endDate);
        }

        const { data, error } = await query;

        if (error) throw error;
        return data || [];
    }

    /**
     * Get doctor's payout history
     */
    async getDoctorPayouts(doctorId: string): Promise<Transaction[]> {
        return this.getDoctorTransactions(doctorId, {
            type: 'payout',
            status: 'completed'
        });
    }

    /**
     * Calculate doctor's total earnings
     */
    async getDoctorEarnings(doctorId: string, startDate?: string, endDate?: string): Promise<number> {
        const transactions = await this.getDoctorTransactions(doctorId, {
            type: 'payout',
            status: 'completed',
            startDate,
            endDate
        });

        return transactions.reduce((total, transaction) => total + transaction.amount, 0);
    }
}

export const paymentService = new PaymentService();
